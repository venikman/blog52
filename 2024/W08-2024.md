# Git

Let's talk about Git. It is one of the most essential tools for software engineers and one of the
most significant tools that push towards Open source, which pushed the whole software development
industry, and this is why I was able to get into this industry myself.

However, Git is a local tool, which is only half of the truth because the second part is remote
functionality and one of the leading players -> Github. I also want to mention and talk about
Github!

So, let's go back in time...

## History

On April 7th, 2005, Linus Torvalds (the Linux creator) created the initial Git version control
system. Approximately 2 years after Git's creation, Github was founded and launched in early 2008.
According to Wikipedia, GitHub was Founded on February 8, 2008, and the Development of the GitHub
platform began on October 19, 2007, but the commit date was October 10, 2007. I wish we could see
_THE_ first commit on GitHub, but it was probably private, and/or commits done for the GitHub
codebase were moved into GitHub, too. There is an
[Issue with the conversation at a very old repo](https://github.com/mojombo/grit/issues/260) where
according to some API: [grit](https://api.github.com/repos/mojombo/grit) -
`"created_at": "2007-10-29T14:37:16Z"`, this is the first commit at GitHub.

## Git as a tool

Even since I started (about 8 years ago), the programming functionality of the Git that I am using
has not changed. I got better at thinking about concepts and what could be done, but it was just
juggling the same things. However, it gets new features regularly. From
[_mirror_ repo](https://github.com/git/git) on GitHub. You can see that for almost over 18 years,
there has been the same amount of activity, with a total of 72k commits:
![[ZET/Sumaries/assets/Screenshot 2024-02-25 at 11.01.04 AM.png]]

What is being developed all this time? Is it just some bug fixes and security updates? New features
are developed, really new features. Recently, I watched a talk, you can watch it yourself on
[Youtube](https://www.youtube.com/watch?v=aolI_Rz0ZqY) about some new functionality from the former
cofounder of GitHub - Scott Chacon. He has also authored the highly influential book "Pro Git." He
left GitHub in 2016. I am not going to cover talk (only as a teaser: did you know you can set a cron
task for git to run some commands like `git fetch` in the background?); what I want to share that at
the end of the talk Scott shared that he still following his same passion -> Git and he has been
working on new tool to make git even more powerful based on his experience that he got over years
and to address all needs of modern software development:
[GitButler | Git Branching, Refined](https://gitbutler.com/). I have yet to play with it, but this
is on my list, so I will keep you posted.

# Define your WHY for my teammates at the Forum group

I have been part of the forum group for 2 years already, and it's been a journey for us (for me, for
sure). I have never seen them in real life, but we still have excellent communication, talking about
some topics that are hard to talk about with people you see daily, and that helps us to grow
personally. We are trying to diversify our activities as much as possible (some could meet in person
doing this), even for online meetings, from goal setting to personal _spiritual_ inner-self work.
Everyone is trying to bring to the table what they can offer, and this time, I wanted to share what
I have learned from Simon's Sinek framework of defining personal "WHY." I have already
[[Publish/2024/W1-2024#Forum Group|shared my goal about it]]. This time, on our call, I have tried
to share which steps they can take to start the journey because it is not only about defining your
indeed "WHY" that belongs to each one and what I have been gaining as I was working on it (I am
still working on it) is to learn about myself. I spent little time on preparation, which was a
mistake; since I have been translating my understanding from English to Russian, it was much harder
than I thought it would be, which is why some of the motivation has been lost. Still, we agreed to
work on it, and we will get together next time. We have some sharing. Everyone got a task to come up
with their personal stories and get with their pairs between our calls, share them, and find some
themes in the stories so everyone can start identifying their personalities better.

# Productivity

## Ergonomic mouse and keyboard

Part of my attention has been dedicated to ergonomics keyboards and mice; I do have some
rationalization for why I should keep attention to it - I have 2 workstations(personal and work),
and I have only one 1pair (keyboard and mouse), which I want to use on both places. I have
[Kinesis Advantage360 Keyboard | Technical Support Resources](https://kinesis-ergo.com/support/kb360/)
and what I am doing is moving it from one table to another with the mouse
([MX Master 3S Wireless Performance Mouse | Logitech](https://www.logitech.com/en-us/products/mice/mx-master-3s.910-006557.html)
which is 4years old! still awesome). I desire to avoid moving around my set from one place to
another and to make it happen, there are only two choices: combine workstations into one or get a
second set. I have been using a single workstation before, and it was ok, but I like that transition
between work and personal state (actually, my last half year was spent removing this line and having
the whole thing as one object of my attention). So here are my observations and thoughts:

### Keyboard

My kinesis is still the best option on the market. There is only one new hero in the town -
[Glove80 Keyboards - MoErgo](https://www.moergo.com/collections/glove80-keyboards), which is better
a bit, compared to Kinesis. As a recommendation for current buyers: get Glow now if you don't have
kinesis. If you have Kinesis - stay with it. Glow does not give you that much that it can
rationalize the replacement of Kinesis. My takeaway: I will do it(by Glow) only if I can get enough
money on the health app for the keyboard. But I have other options to spend them as well, hehe. We
will see each other in July...

### Mouse

MX3 has
[new update for Macs](https://www.logitech.com/en-us/products/mice/mx-master-3s-mac-bluetooth-mouse.910-006570.html),
and since I have had my current MX3 for 4 years almost time to get a second one just in case and see
if there is a real difference. My main concern is battery life. Recently (in the last few months), I
had to charge it a few times, whereas before, I do not remember doing this more than once a year.

## Obsidian and readwise

Surfing around YouTube recommended "another one" video(not worth even sharing the link) with
Obsidian Plugins' recommendation. I have decided to look through it to check the plugin's name. I
have written down a few that I did not know to check if they could have the potential for my
adoption. Surprisingly, one of them was worth my attention: a plugin for integration with
[Readwise](https://readwise.io/) tool. It is not that special to sync the highlights you make
digitally while reading PDFs or articles or just surfing the web because you still have to have some
convenient mechanism; I didn't have it until I learned that Readwise (great timing for me to
discover it now) is working on a new tool: [ReaderNew](https://readwise.io/read) and this was a
dealbreaker for me... It's offering very easy integration from every channel I am consuming: X,
YouTube, email, Substack... I did test it with X for now, but it was already impressive: While
reading X posts, I can hit 1 button, and every selection(highlight) I make will end up in my
Obsidian vault. I should share more about this integration as I will do it more.

# DDD workshop

I have started to talk about it from [[Publish/2024/W2-2024#Scott Wlaschin, Domain Modeling Made
Functional|1st week of the year]], and this week was the week! Following all learning concepts:
spread learning, juggling formats of the information consumption (visual, lecture, reading) and
practice (collaboration, solo work), 2 first days of 4 were awesome! Going through Modeling on the
first day and covering FP(function programming) and F# concepts on the second, letting that
information settle in the long-term memory for the next two days will be as valuable as the first
two.

Having [Scott's book](https://pragprog.com/titles/swdddf/domain-modeling-made-functional/) as extra
material around this workshop, putting my brain into deeper diving for this topic, I have started
reading this book before the workshop, covering more material on week-gap between 2 parts of the
workshop and planning to finish this book very soon after workshop, with the flavor of practicing of
speaking/reasoning with my coworker Eric, in my opinion, do not leave me a chance to not use this
new knowledge (DDD and F# language and functional programming way of building software) in my daily
job immediately.

Here is an exciting spin-off from reading the DDD book that triggered my slow-cooking
[[Publish/2024/W5-2024#Event-driven pattern|idea]] from talking about the theoretical topic: State
Machine and [[Publish/2024/W5-2024#XState, Actor model.|Actor model]]

## State Machine(SM) vs Actor Model(AM)

So far, what I have learned is that both patterns of modeling have the main difference in the scope
of the area being described by the model; practically, we can say that _SM_ focuses on covering
fully the end-to-end state of the system that you control - the local one. And _AM_ assumes that
multiple actors(like agents) can not be fully controlled in one place - like services/systems that
are part of the bigger scope related to the system from which _AM_ Description is happening, like
distributed systems. And since DDD is usually trying to be involved in _a bounded context_ this is
where you can have more control and fully cover potential states of the system.

### Gemini's opinion

While reading the book I have been using Gemini
([LLM from Google, that gave 2 months free use](https://blog.google/products/gemini/bard-gemini-advanced-app/)),
I asked to explain those two patterns and what the difference:

**Fundamental Concepts**

- **Actor Model:**
  - **Units of Computation:** Individual, autonomous actors
  - **Communication:** Asynchronous messages between actors
  - **Focus:** Concurrency, distribution, and fault tolerance. Ideal for modeling systems where
    independent components need to react to events and coordinate actions.
- **Finite State Machines (FSMs):**
  - **Units of Computation:** A single system with well-defined states
  - **Communication:** Inputs (events or triggers) that cause state transitions
  - **Focus:** Modeling the precise behavior of a system within a specific context or component.
    Ideal for situations with clear sequences of states and their corresponding reactions.

**Key Differences**

1. **Scope:**

   - **Actor Model:** Encompasses how multiple components interact in a system. It's a higher-level
     view of system design.
   - **FSM:** Models the behavior of a single component or subsystem within a larger context.
2. **Concurrency:**

   - **Actor Model:** Inherently built for concurrent systems with many actors processing messages
     and working simultaneously.
   - **FSM:** A single FSM is not inherently concurrent. You can have multiple FSMs running
     concurrently, but the concept focuses on a sequential series of states.
3. **Communication:**

   - **Actor Model:** Actors communicate through asynchronous messages. They can send messages and
     continue with other tasks without waiting for a direct response.
   - **FSM:** Reacts to inputs or events, driving state transitions. The input and state change are
     tightly coupled.
4. **Scalability and Distribution:**

   - **Actor Model:** Designed to scale across multiple machines in distributed environments.
   - **FSM:** While FSMs can be used in distributed systems, they don’t inherently address
     distribution similarly.

**When to Choose Which**

- **Actor Model:**
  - Systems with many independent components that need to interact.
  - Systems where responsiveness and resilience to failure are major concerns.
  - When you want scalability and distribution.
- **Finite State Machine:**
  - Modeling a system component that has clearly defined states and transitions.
  - Situations where precisely tracking and controlling sequences of events is key.

**Note:** Actor Model and FSMs can be complementary! You can use FSMs to model the internal logic of
actors within a larger system designed upon the Actor Model.

---

End of Gemini's response. (No changes to text have been made.)

P.S. My explanation was based on reading this response, but it is my current understanding.

After some research on this topic, I have found a book from Gemini's recommendations that triggered
my interest:
[Introduction to the Theory of Computation: Sipser, Michael: 9781133187790: Amazon.com: Books](https://www.amazon.com/dp/113318779X?psc=1&ref=ppx_yo2ov_dt_b_product_details)
and marketing laws worked on me. It was 69% off and since this book is very expensive, I couldn't
ignore it so that it will be delivered next week.
